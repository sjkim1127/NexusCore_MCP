use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use crate::sandbox::cape::CapeClient;

pub struct CapeSubmitter;

use std::env;

#[async_trait]
impl Tool for CapeSubmitter {
    fn name(&self) -> &str { "cape_submit" }
    fn description(&self) -> &str { "Submits a file to CAPEv2 sandbox. Args: file_path, machine (opt), timeout (opt), base_url (opt)" }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let file_path = args["file_path"].as_str().ok_or(anyhow::anyhow!("Missing file_path"))?;
        
        // Priority: Argument -> Env Var -> Default Localhost
        let base_url = args["base_url"].as_str()
            .map(|s| s.to_string())
            .or_else(|| env::var("CAPE_API_URL").ok())
            .unwrap_or_else(|| "http://127.0.0.1:8000".to_string());
            
        let token = env::var("CAPE_API_TOKEN").unwrap_or_default();

        let machine = args["machine"].as_str();
        let timeout = args["timeout"].as_u64().unwrap_or(300);

        let client = CapeClient::new(&base_url, &token);

        tracing::info!("Submitting {} to CAPE at {}", file_path, base_url);
        let task_id = client.submit_file(file_path, machine).await?;
        
        tracing::info!("File submitted. Task ID: {}. Waiting for analysis...", task_id);
        
        // Wait logic
        match client.wait_for_analysis(task_id, timeout).await {
            Ok(status) => {
                tracing::info!("Analysis completed with status: {}", status);
                
                // Fetch report
                let report = client.get_report(task_id).await?;
                
                // Return a simplified summary or full report?
                // Full report is huge. Let's return the full JSON and let the Agent parse/filter.
                // But add our own metadata wrapper.
                Ok(serde_json::json!({
                    "status": "analysis_finished",
                    "task_id": task_id,
                    "cape_status": status,
                    "report": report
                }))
            },
            Err(e) => {
                Err(anyhow::anyhow!("Analysis timeout or failed: {}", e))
            }
        }
    }
}

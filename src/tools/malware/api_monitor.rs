use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use async_trait::async_trait;

/// Available API monitoring categories
const CATEGORIES: &[&str] = &["file", "registry", "network", "memory", "process"];

/// API Monitor Tool
///
/// Monitors Windows API calls using Frida instrumentation.
/// Supports multiple categories: file, registry, network, memory, process
pub struct ApiMonitor;

#[async_trait]
impl Tool for ApiMonitor {
    fn name(&self) -> &str { "api_monitor" }

    fn description(&self) -> &str {
        "Monitors Windows API calls in a process. Args: pid (number), categories (array of: 'file', 'registry', 'network', 'memory', 'process'), all categories monitored if not specified"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        // Parse categories or use all
        let categories: Vec<String> = if let Some(cats) = args["categories"].as_array() {
            cats.iter()
                .filter_map(|v| v.as_str())
                .filter(|c| CATEGORIES.contains(c))
                .map(|s| s.to_string())
                .collect()
        } else {
            CATEGORIES.iter().map(|s| s.to_string()).collect()
        };

        if categories.is_empty() {
            return Err(anyhow::anyhow!(
                "No valid categories specified. Available: {:?}",
                CATEGORIES
            ));
        }

        // Build configuration for the script
        let config_json = serde_json::json!({
            "categories": categories
        });

        // Load the API monitor script with configuration
        let script = format!(
            r#"
            var monitorConfig = {};
            {}
            "#,
            config_json.to_string(),
            include_str!("../../resources/scripts/api_monitor.js")
        );

        // Inject the script
        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "monitoring",
            "pid": pid,
            "categories": categories,
            "message": format!("API monitoring started for PID {}. Events will be sent via Frida message handler.", pid)
        }))
    }
}

/// Preset API Monitor for quick file operation monitoring
pub struct FileMonitor;

#[async_trait]
impl Tool for FileMonitor {
    fn name(&self) -> &str { "file_monitor" }

    fn description(&self) -> &str {
        "Monitors file operations (CreateFile, WriteFile, DeleteFile, etc). Args: pid (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        let script = format!(
            r#"
            var monitorConfig = {{ categories: ['file'] }};
            {}
            "#,
            include_str!("../../resources/scripts/api_monitor.js")
        );

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "monitoring",
            "pid": pid,
            "category": "file",
            "apis": ["CreateFileW", "WriteFile", "DeleteFileW", "CopyFileW", "MoveFileW"]
        }))
    }
}

/// Preset API Monitor for registry operation monitoring
pub struct RegistryMonitor;

#[async_trait]
impl Tool for RegistryMonitor {
    fn name(&self) -> &str { "registry_monitor" }

    fn description(&self) -> &str {
        "Monitors registry operations (RegCreateKey, RegSetValue, etc). Args: pid (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        let script = format!(
            r#"
            var monitorConfig = {{ categories: ['registry'] }};
            {}
            "#,
            include_str!("../../resources/scripts/api_monitor.js")
        );

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "monitoring",
            "pid": pid,
            "category": "registry",
            "apis": ["RegCreateKeyExW", "RegSetValueExW", "RegDeleteKeyW", "RegDeleteValueW"]
        }))
    }
}

/// Preset API Monitor for network operation monitoring
pub struct NetworkMonitor;

#[async_trait]
impl Tool for NetworkMonitor {
    fn name(&self) -> &str { "network_monitor" }

    fn description(&self) -> &str {
        "Monitors network operations (connect, send, recv, DNS). Args: pid (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        let script = format!(
            r#"
            var monitorConfig = {{ categories: ['network'] }};
            {}
            "#,
            include_str!("../../resources/scripts/api_monitor.js")
        );

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "monitoring",
            "pid": pid,
            "category": "network",
            "apis": ["connect", "send", "recv", "WSAConnect", "GetAddrInfoW"]
        }))
    }
}

/// Preset API Monitor for process injection detection
pub struct InjectionMonitor;

#[async_trait]
impl Tool for InjectionMonitor {
    fn name(&self) -> &str { "injection_monitor" }

    fn description(&self) -> &str {
        "Monitors for process injection techniques (CreateRemoteThread, WriteProcessMemory, etc). Args: pid (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        let script = format!(
            r#"
            var monitorConfig = {{ categories: ['process', 'memory'] }};
            {}
            "#,
            include_str!("../../resources/scripts/api_monitor.js")
        );

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "monitoring",
            "pid": pid,
            "categories": ["process", "memory"],
            "apis": [
                "CreateProcessW", "CreateRemoteThread", "OpenProcess",
                "WriteProcessMemory", "NtCreateThreadEx",
                "VirtualAlloc", "VirtualProtect", "VirtualAllocEx"
            ],
            "note": "Watching for potential injection techniques"
        }))
    }
}

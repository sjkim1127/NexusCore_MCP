use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use std::process::Command;
use std::fs;
use std::path::PathBuf;

/// x64dbg Launcher - Launches target in x64dbg with optional script
pub struct X64dbgLauncher;

#[async_trait]
impl Tool for X64dbgLauncher {
    fn name(&self) -> &str { "debug_launch" }
    fn description(&self) -> &str { "Launches a file in x64dbg debugger. Args: path (exe path), script (optional .txt script path)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let target_path = args["path"].as_str().ok_or(anyhow::anyhow!("Missing path"))?;
        let script_path = args["script"].as_str();
        
        // Find x64dbg - check common paths
        let x64dbg_paths = [
            "x64dbg.exe",
            "C:\\x64dbg\\release\\x64\\x64dbg.exe",
            "C:\\Program Files\\x64dbg\\release\\x64\\x64dbg.exe",
        ];
        
        let x64dbg = x64dbg_paths.iter()
            .find(|p| std::path::Path::new(p).exists() || which::which(p).is_ok())
            .map(|s| s.to_string())
            .unwrap_or_else(|| "x64dbg.exe".to_string());

        let mut cmd = Command::new(&x64dbg);
        cmd.arg(target_path);
        
        // x64dbg supports -a for arguments and script execution via command line
        if let Some(script) = script_path {
            // x64dbg can execute scripts via stdin or file
            cmd.args(["-script", script]);
        }

        let child = cmd.spawn()
            .map_err(|e| anyhow::anyhow!("Failed to launch x64dbg: {}. Is it in PATH or installed?", e))?;

        Ok(serde_json::json!({
            "status": "launched",
            "target": target_path,
            "script": script_path,
            "x64dbg_pid": child.id()
        }))
    }
}

/// x64dbg Script Runner - Creates and runs automated scripts
pub struct X64dbgScript;

#[async_trait]
impl Tool for X64dbgScript {
    fn name(&self) -> &str { "debug_script" }
    fn description(&self) -> &str { "Creates x64dbg automation script. Args: commands (array of x64dbg commands)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let commands: Vec<String> = args["commands"]
            .as_array()
            .ok_or(anyhow::anyhow!("Missing commands array"))?
            .iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect();

        if commands.is_empty() {
            return Err(anyhow::anyhow!("Commands array is empty"));
        }

        // Generate script content
        let script_content = commands.join("\n");
        
        // Save to temp file
        let script_path = std::env::temp_dir().join("nexuscore_x64dbg_script.txt");
        fs::write(&script_path, &script_content)
            .map_err(|e| anyhow::anyhow!("Failed to write script: {}", e))?;

        Ok(serde_json::json!({
            "status": "script_created",
            "path": script_path.to_string_lossy(),
            "command_count": commands.len(),
            "commands": commands,
            "usage": format!("Use debug_launch with script='{}' to execute", script_path.to_string_lossy())
        }))
    }
}

/// x64dbg Command Generator - Provides common debugging command templates
pub struct X64dbgCommands;

#[async_trait]
impl Tool for X64dbgCommands {
    fn name(&self) -> &str { "debug_commands" }
    fn description(&self) -> &str { "Generates common x64dbg command sequences. Args: action (oep_find/unpack/trace/breakpoint), params" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let action = args["action"].as_str().ok_or(anyhow::anyhow!("Missing action"))?;

        let commands: Vec<&str> = match action {
            "oep_find" => vec![
                "// OEP Finding Script",
                "bphc",  // Clear hardware breakpoints
                "bpc",   // Clear software breakpoints
                "SetBPX VirtualAlloc",
                "SetBPX VirtualProtect", 
                "erun",  // Run until exception/BP
                "log \"Hit memory allocation BP\"",
                "sti",   // Step into
            ],
            "unpack" => vec![
                "// Generic Unpacking Script",
                "bphc",
                "SetBPX VirtualProtect, exec",
                "erun",
                "log \"VirtualProtect called - possible unpacking\"",
                "d esp+8",  // Show protection parameter
                "rtr",      // Return from function
                "d eax",    // Show result
            ],
            "trace" => {
                let count = args["count"].as_u64().unwrap_or(100);
                vec![
                    "// Instruction Trace",
                    "TraceSetLog \"trace.log\"",
                    &format!("TraceSetMaxCount {}", count),
                    "TraceIntoConditional 1",
                ]
            },
            "breakpoint" => {
                let address = args["address"].as_str().unwrap_or("entrypoint");
                vec![
                    &format!("bp {}", address),
                    "erun",
                ]
            },
            "dump_memory" => vec![
                "// Memory Dump",
                "savedata \"dump.bin\", eax, 1000",
                "log \"Memory dumped to dump.bin\"",
            ],
            "anti_anti_debug" => vec![
                "// Anti-Anti-Debug",
                "HideDebugger",
                "DbgSetDebuggerPEB 0",  // Hide PEB debug flag
                "log \"Debugger hidden\"",
            ],
            _ => return Err(anyhow::anyhow!("Unknown action: {}. Use oep_find, unpack, trace, breakpoint, dump_memory, anti_anti_debug", action)),
        };

        Ok(serde_json::json!({
            "action": action,
            "commands": commands,
            "note": "Use debug_script to save these commands, then debug_launch to execute"
        }))
    }
}

/// x64dbg Output Parser - Parses x64dbg log files
pub struct X64dbgLogParser;

#[async_trait]
impl Tool for X64dbgLogParser {
    fn name(&self) -> &str { "parse_debug_log" }
    fn description(&self) -> &str { "Parses x64dbg log file for analysis. Args: path (log file path)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let log_path = args["path"].as_str().ok_or(anyhow::anyhow!("Missing path"))?;
        
        let content = fs::read_to_string(log_path)
            .map_err(|e| anyhow::anyhow!("Failed to read log: {}", e))?;

        // Parse key events
        let mut breakpoints_hit = Vec::new();
        let mut exceptions = Vec::new();
        let mut api_calls = Vec::new();

        for line in content.lines() {
            let line_lower = line.to_lowercase();
            
            if line_lower.contains("breakpoint") {
                breakpoints_hit.push(line.to_string());
            }
            if line_lower.contains("exception") {
                exceptions.push(line.to_string());
            }
            if line_lower.contains("call") || line_lower.contains("api") {
                api_calls.push(line.to_string());
            }
        }

        Ok(serde_json::json!({
            "log_path": log_path,
            "total_lines": content.lines().count(),
            "breakpoints_hit": breakpoints_hit.len(),
            "exceptions": exceptions.len(),
            "api_calls_detected": api_calls.len(),
            "sample_breakpoints": breakpoints_hit.iter().take(10).collect::<Vec<_>>(),
            "sample_exceptions": exceptions.iter().take(5).collect::<Vec<_>>()
        }))
    }
}

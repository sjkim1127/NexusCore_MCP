use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use std::process::{Command, Stdio};
use std::io::Write;
use std::fs;

/// WinDbg Console Debugger (cdb.exe) - Completely Headless
/// 
/// cdb.exe is the command-line version of WinDbg, no GUI required.
/// Part of Windows SDK / Debugging Tools for Windows.

/// Debug with cdb.exe - Launch and debug a process
pub struct CdbDebugger;

#[async_trait]
impl Tool for CdbDebugger {
    fn name(&self) -> &str { "debug_process" }
    fn description(&self) -> &str { "Debug a process with cdb.exe (headless). Args: path (exe), commands (array of debugger commands)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let target_path = args["path"].as_str().ok_or(anyhow::anyhow!("Missing path"))?;
        let commands: Vec<String> = args["commands"]
            .as_array()
            .map(|arr| arr.iter().filter_map(|v| v.as_str().map(String::from)).collect())
            .unwrap_or_else(|| vec!["g".to_string(), "q".to_string()]); // Default: go, quit

        // Build command script
        let script = commands.join("\n");
        
        // Run cdb.exe with script via stdin
        let mut child = Command::new("cdb.exe")
            .args(["-o", target_path]) // -o: debug child processes too
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| anyhow::anyhow!("Failed to launch cdb.exe: {}. Is Debugging Tools for Windows installed?", e))?;

        // Send commands
        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(script.as_bytes())?;
            stdin.write_all(b"\nq\n")?; // Ensure quit at end
        }

        let output = child.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        Ok(serde_json::json!({
            "status": if output.status.success() { "completed" } else { "error" },
            "exit_code": output.status.code(),
            "output": stdout.lines().take(100).collect::<Vec<_>>().join("\n"),
            "stderr": stderr.to_string()
        }))
    }
}

/// Attach to running process with cdb.exe
pub struct CdbAttach;

#[async_trait]
impl Tool for CdbAttach {
    fn name(&self) -> &str { "debug_attach" }
    fn description(&self) -> &str { "Attach cdb.exe to a running process. Args: pid (number), commands (array)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let commands: Vec<String> = args["commands"]
            .as_array()
            .map(|arr| arr.iter().filter_map(|v| v.as_str().map(String::from)).collect())
            .unwrap_or_else(|| vec!["~*k".to_string(), "q".to_string()]); // Default: all callstacks, quit

        let script = commands.join("\n");

        let mut child = Command::new("cdb.exe")
            .args(["-p", &pid.to_string()])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| anyhow::anyhow!("Failed to attach cdb.exe: {}", e))?;

        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(script.as_bytes())?;
            stdin.write_all(b"\nq\n")?;
        }

        let output = child.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);

        Ok(serde_json::json!({
            "status": "completed",
            "pid": pid,
            "output": stdout.lines().take(100).collect::<Vec<_>>().join("\n")
        }))
    }
}

/// Memory dump with cdb.exe
pub struct CdbMemoryDump;

#[async_trait]
impl Tool for CdbMemoryDump {
    fn name(&self) -> &str { "debug_memdump" }
    fn description(&self) -> &str { "Dump process memory with cdb.exe. Args: pid (number), address (hex), size (number)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().unwrap_or("0");
        let size = args["size"].as_u64().unwrap_or(256);

        // db = display bytes
        let commands = vec![
            format!("db {} L{:x}", address, size),
            "q".to_string(),
        ];

        let mut child = Command::new("cdb.exe")
            .args(["-p", &pid.to_string()])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| anyhow::anyhow!("Failed to run cdb.exe: {}", e))?;

        if let Some(mut stdin) = child.stdin.take() {
            for cmd in &commands {
                writeln!(stdin, "{}", cmd)?;
            }
        }

        let output = child.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);

        Ok(serde_json::json!({
            "pid": pid,
            "address": address,
            "size": size,
            "hex_dump": stdout.lines()
                .filter(|l| l.contains("`") || l.starts_with("0"))
                .take(50)
                .collect::<Vec<_>>()
                .join("\n")
        }))
    }
}

/// Disassemble with cdb.exe
pub struct CdbDisassemble;

#[async_trait]
impl Tool for CdbDisassemble {
    fn name(&self) -> &str { "debug_disasm" }
    fn description(&self) -> &str { "Disassemble code with cdb.exe. Args: pid (number), address (hex), count (number of instructions)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().unwrap_or("@rip");
        let count = args["count"].as_u64().unwrap_or(20);

        // u = unassemble
        let commands = vec![
            format!("u {} L{:x}", address, count),
            "q".to_string(),
        ];

        let mut child = Command::new("cdb.exe")
            .args(["-p", &pid.to_string()])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| anyhow::anyhow!("Failed to run cdb.exe: {}", e))?;

        if let Some(mut stdin) = child.stdin.take() {
            for cmd in &commands {
                writeln!(stdin, "{}", cmd)?;
            }
        }

        let output = child.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse disassembly lines
        let disasm: Vec<&str> = stdout.lines()
            .filter(|l| l.contains("`") || l.starts_with("0"))
            .take(50)
            .collect();

        Ok(serde_json::json!({
            "pid": pid,
            "address": address,
            "instructions": disasm
        }))
    }
}

/// Get registers with cdb.exe
pub struct CdbRegisters;

#[async_trait]
impl Tool for CdbRegisters {
    fn name(&self) -> &str { "debug_registers" }
    fn description(&self) -> &str { "Get CPU registers with cdb.exe. Args: pid (number)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;

        let commands = vec!["r", "q"];

        let mut child = Command::new("cdb.exe")
            .args(["-p", &pid.to_string()])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| anyhow::anyhow!("Failed to run cdb.exe: {}", e))?;

        if let Some(mut stdin) = child.stdin.take() {
            for cmd in &commands {
                writeln!(stdin, "{}", cmd)?;
            }
        }

        let output = child.wait_with_output()?;
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse register lines
        let regs: Vec<&str> = stdout.lines()
            .filter(|l| l.contains("=") && !l.contains("Microsoft"))
            .take(20)
            .collect();

        Ok(serde_json::json!({
            "pid": pid,
            "registers": regs
        }))
    }
}

/// Common cdb.exe command reference
pub struct CdbCommands;

#[async_trait]
impl Tool for CdbCommands {
    fn name(&self) -> &str { "debug_help" }
    fn description(&self) -> &str { "Get common cdb.exe debugger commands reference" }

    async fn execute(&self, _args: Value) -> Result<Value> {
        Ok(serde_json::json!({
            "execution": {
                "g": "Go (run)",
                "p": "Step over",
                "t": "Step into (trace)",
                "gu": "Step out (go up)",
                "q": "Quit"
            },
            "breakpoints": {
                "bp <addr>": "Set breakpoint",
                "bc *": "Clear all breakpoints",
                "bl": "List breakpoints"
            },
            "memory": {
                "db <addr>": "Display bytes",
                "dd <addr>": "Display dwords",
                "dq <addr>": "Display qwords",
                "da <addr>": "Display ASCII",
                "du <addr>": "Display Unicode"
            },
            "disassembly": {
                "u <addr>": "Unassemble",
                "uf <func>": "Unassemble function"
            },
            "registers": {
                "r": "Display registers",
                "r <reg>=<val>": "Set register"
            },
            "stack": {
                "k": "Stack trace",
                "~*k": "All threads stack"
            },
            "modules": {
                "lm": "List modules",
                "x <mod>!*": "List symbols"
            }
        }))
    }
}

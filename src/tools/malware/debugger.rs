use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use std::collections::HashMap;
use std::process::{Command, Stdio, Child, ChildStdin, ChildStdout};
use std::sync::{Mutex, Arc};
use std::io::{Write, BufRead, BufReader};
use std::thread;
use std::sync::mpsc::{channel, Sender, Receiver};

/// Global session store
static SESSIONS: std::sync::OnceLock<Mutex<SessionStore>> = std::sync::OnceLock::new();

fn get_sessions() -> &'static Mutex<SessionStore> {
    SESSIONS.get_or_init(|| Mutex::new(SessionStore::new()))
}

struct DebugSession {
    child: Child,
    stdin: ChildStdin,
    output_rx: Receiver<String>,
    pid: u32,
}

struct SessionStore {
    sessions: HashMap<String, DebugSession>,
    next_id: u32,
}

impl SessionStore {
    fn new() -> Self {
        Self {
            sessions: HashMap::new(),
            next_id: 1,
        }
    }

    fn create_session(&mut self, target: &str, attach_pid: Option<u32>) -> Result<String> {
        let session_id = format!("session_{}", self.next_id);
        self.next_id += 1;

        // Build cdb.exe command
        let mut cmd = Command::new("cdb.exe");
        
        if let Some(pid) = attach_pid {
            cmd.args(["-p", &pid.to_string()]);
        } else {
            cmd.args(["-o", target]); // -o for child process debugging
        }

        cmd.stdin(Stdio::piped())
           .stdout(Stdio::piped())
           .stderr(Stdio::piped());

        let mut child = cmd.spawn()
            .map_err(|e| anyhow::anyhow!("Failed to start cdb.exe: {}", e))?;

        let stdin = child.stdin.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to get stdin"))?;
        
        let stdout = child.stdout.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to get stdout"))?;

        // Create channel for async output reading
        let (tx, rx) = channel::<String>();
        
        // Spawn thread to read stdout
        thread::spawn(move || {
            let reader = BufReader::new(stdout);
            for line in reader.lines() {
                if let Ok(line) = line {
                    let _ = tx.send(line);
                }
            }
        });

        let pid = child.id();
        
        self.sessions.insert(session_id.clone(), DebugSession {
            child,
            stdin,
            output_rx: rx,
            pid,
        });

        Ok(session_id)
    }

    fn send_command(&mut self, session_id: &str, command: &str) -> Result<Vec<String>> {
        let session = self.sessions.get_mut(session_id)
            .ok_or_else(|| anyhow::anyhow!("Session not found: {}", session_id))?;

        // Send command
        writeln!(session.stdin, "{}", command)?;
        session.stdin.flush()?;

        // Give debugger time to process
        std::thread::sleep(std::time::Duration::from_millis(100));

        // Collect output
        let mut output = Vec::new();
        while let Ok(line) = session.output_rx.try_recv() {
            output.push(line);
        }

        Ok(output)
    }

    fn end_session(&mut self, session_id: &str) -> Result<()> {
        if let Some(mut session) = self.sessions.remove(session_id) {
            // Send quit command
            let _ = writeln!(session.stdin, "q");
            let _ = session.stdin.flush();
            
            // Wait for process to exit
            let _ = session.child.wait();
        }
        Ok(())
    }

    fn list_sessions(&self) -> Vec<(String, u32)> {
        self.sessions.iter()
            .map(|(id, s)| (id.clone(), s.pid))
            .collect()
    }
}

/// Start a new debug session
pub struct SessionStart;

#[async_trait]
impl Tool for SessionStart {
    fn name(&self) -> &str { "session_start" }
    fn description(&self) -> &str { "Start a persistent debug session. Args: path (exe) OR pid (attach to existing). Returns session_id." }

    async fn execute(&self, args: Value) -> Result<Value> {
        let mut store = get_sessions().lock().unwrap();
        
        let session_id = if let Some(pid) = args["pid"].as_u64() {
            store.create_session("", Some(pid as u32))?
        } else if let Some(path) = args["path"].as_str() {
            store.create_session(path, None)?
        } else {
            return Err(anyhow::anyhow!("Provide 'path' or 'pid'"));
        };

        // Wait for initial output
        std::thread::sleep(std::time::Duration::from_millis(500));
        
        // Collect startup output
        let output = store.send_command(&session_id, "")?;

        Ok(serde_json::json!({
            "status": "session_started",
            "session_id": session_id,
            "startup_output": output.join("\n")
        }))
    }
}

/// Send command to existing session
pub struct SessionCommand;

#[async_trait]
impl Tool for SessionCommand {
    fn name(&self) -> &str { "session_command" }
    fn description(&self) -> &str { "Send command to debug session. Args: session_id, command (string)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let session_id = args["session_id"].as_str()
            .ok_or(anyhow::anyhow!("Missing session_id"))?;
        let command = args["command"].as_str()
            .ok_or(anyhow::anyhow!("Missing command"))?;

        let mut store = get_sessions().lock().unwrap();
        let output = store.send_command(session_id, command)?;

        Ok(serde_json::json!({
            "session_id": session_id,
            "command": command,
            "output": output
        }))
    }
}

/// Send multiple commands to session
pub struct SessionBatch;

#[async_trait]
impl Tool for SessionBatch {
    fn name(&self) -> &str { "session_batch" }
    fn description(&self) -> &str { "Send multiple commands to session. Args: session_id, commands (array)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let session_id = args["session_id"].as_str()
            .ok_or(anyhow::anyhow!("Missing session_id"))?;
        let commands: Vec<String> = args["commands"]
            .as_array()
            .ok_or(anyhow::anyhow!("Missing commands array"))?
            .iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect();

        let mut store = get_sessions().lock().unwrap();
        let mut results = Vec::new();

        for cmd in &commands {
            let output = store.send_command(session_id, cmd)?;
            results.push(serde_json::json!({
                "command": cmd,
                "output": output
            }));
        }

        Ok(serde_json::json!({
            "session_id": session_id,
            "results": results
        }))
    }
}

/// End debug session
pub struct SessionEnd;

#[async_trait]
impl Tool for SessionEnd {
    fn name(&self) -> &str { "session_end" }
    fn description(&self) -> &str { "End a debug session. Args: session_id" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let session_id = args["session_id"].as_str()
            .ok_or(anyhow::anyhow!("Missing session_id"))?;

        let mut store = get_sessions().lock().unwrap();
        store.end_session(session_id)?;

        Ok(serde_json::json!({
            "status": "session_ended",
            "session_id": session_id
        }))
    }
}

/// List all active sessions
pub struct SessionList;

#[async_trait]
impl Tool for SessionList {
    fn name(&self) -> &str { "session_list" }
    fn description(&self) -> &str { "List all active debug sessions" }

    async fn execute(&self, _args: Value) -> Result<Value> {
        let store = get_sessions().lock().unwrap();
        let sessions: Vec<_> = store.list_sessions()
            .into_iter()
            .map(|(id, pid)| serde_json::json!({ "session_id": id, "cdb_pid": pid }))
            .collect();

        Ok(serde_json::json!({
            "active_sessions": sessions
        }))
    }
}

/// Common cdb.exe command reference
pub struct CdbCommands;

#[async_trait]
impl Tool for CdbCommands {
    fn name(&self) -> &str { "debug_help" }
    fn description(&self) -> &str { "Get common cdb.exe debugger commands reference" }

    async fn execute(&self, _args: Value) -> Result<Value> {
        Ok(serde_json::json!({
            "workflow": [
                "1. session_start(path='/path/to/exe') → get session_id",
                "2. session_command(session_id, 'bp main') → set breakpoint",
                "3. session_command(session_id, 'g') → run",
                "4. session_command(session_id, 'r') → view registers",
                "5. session_end(session_id) → cleanup"
            ],
            "execution": {
                "g": "Go (run)",
                "p": "Step over",
                "t": "Step into (trace)",
                "gu": "Step out (go up)"
            },
            "breakpoints": {
                "bp <addr>": "Set breakpoint",
                "bc *": "Clear all breakpoints",
                "bl": "List breakpoints"
            },
            "memory": {
                "db <addr>": "Display bytes",
                "dd <addr>": "Display dwords",
                "dq <addr>": "Display qwords"
            },
            "disassembly": {
                "u <addr>": "Unassemble",
                "uf <func>": "Unassemble function"
            },
            "registers": {
                "r": "Display registers",
                "r <reg>=<val>": "Set register"
            },
            "stack": {
                "k": "Stack trace",
                "~*k": "All threads stack"
            }
        }))
    }
}

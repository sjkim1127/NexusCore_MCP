use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use crate::utils::cache::{get_cache, file_hash};
use async_trait::async_trait;
use tokio::process::Command;
use std::path::Path;
use std::time::Instant;

/// Helper: Check cache or execute command
async fn cached_tool_execute(
    tool_name: &str,
    file_path: &str,
    cmd: &str,
    args: &[&str],
) -> Result<(Value, bool)> {
    // Generate cache key
    let hash = match file_hash(file_path) {
        Ok(h) => format!("{}:{}", tool_name, h),
        Err(_) => return execute_command(cmd, args, file_path).await.map(|v| (v, false)),
    };

    // Check cache
    {
        let cache = get_cache().lock().unwrap();
        if let Some(cached) = cache.get(&hash) {
            return Ok((cached.clone(), true));
        }
    }

    // Execute and cache
    let result = execute_command(cmd, args, file_path).await?;
    
    {
        let mut cache = get_cache().lock().unwrap();
        cache.insert(hash, result.clone());
    }

    Ok((result, false))
}

async fn execute_command(cmd: &str, args: &[&str], file_path: &str) -> Result<Value> {
    let output = Command::new(cmd)
        .args(args)
        .arg(file_path)
        .output()
        .await?;

    if !output.status.success() {
        return Err(anyhow::anyhow!("{} failed: {}", cmd, String::from_utf8_lossy(&output.stderr)));
    }

    let stdout = String::from_utf8(output.stdout)?;
    Ok(serde_json::from_str(&stdout).unwrap_or(serde_json::json!({"raw": stdout})))
}

pub struct DieTool;

#[async_trait]
impl Tool for DieTool {
    fn name(&self) -> &str { "die_scan" }
    fn description(&self) -> &str { "Analyzes file signatures (compiler, packer) using Detect It Easy. Args: file_path" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("file_path", "string", true, "Path to file") ])
    }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let path = match args["file_path"].as_str() {
            Some(p) => p,
            None => return Ok(StandardResponse::error(tool_name, "Missing file_path")),
        };

        match cached_tool_execute(tool_name, path, "diec", &["-j"]).await {
            Ok((result, cached)) => {
                if cached {
                    Ok(StandardResponse::success_cached(tool_name, result))
                } else {
                    Ok(StandardResponse::success_timed(tool_name, result, start))
                }
            },
            Err(e) => Ok(StandardResponse::error(tool_name, &e.to_string())),
        }
    }
}

pub struct CapaTool;

#[async_trait]
impl Tool for CapaTool {
    fn name(&self) -> &str { "capa_scan" }
    fn description(&self) -> &str { "Identifies capabilities using MITRE ATT&CK mapping. Args: file_path" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("file_path", "string", true, "Path to file") ])
    }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let path = match args["file_path"].as_str() {
            Some(p) => p,
            None => return Ok(StandardResponse::error(tool_name, "Missing file_path")),
        };

        match cached_tool_execute(tool_name, path, "capa", &["-j"]).await {
            Ok((result, cached)) => {
                if cached {
                    Ok(StandardResponse::success_cached(tool_name, result))
                } else {
                    Ok(StandardResponse::success_timed(tool_name, result, start))
                }
            },
            Err(e) => Ok(StandardResponse::error(tool_name, &e.to_string())),
        }
    }
}

pub struct FlossTool;

#[async_trait]
impl Tool for FlossTool {
    fn name(&self) -> &str { "floss_strings" }
    fn description(&self) -> &str { "Extracts obfuscated strings using FLOSS. Args: file_path" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("file_path", "string", true, "Path to file") ])
    }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let path = match args["file_path"].as_str() {
            Some(p) => p,
            None => return Ok(StandardResponse::error(tool_name, "Missing file_path")),
        };

        match cached_tool_execute(tool_name, path, "floss", &["-j"]).await {
            Ok((result, cached)) => {
                if cached {
                    Ok(StandardResponse::success_cached(tool_name, result))
                } else {
                    Ok(StandardResponse::success_timed(tool_name, result, start))
                }
            },
            Err(e) => Ok(StandardResponse::error(tool_name, &e.to_string())),
        }
    }
}

pub struct ProcDumpTool;

#[async_trait]
impl Tool for ProcDumpTool {
    fn name(&self) -> &str { "procdump" }
    fn description(&self) -> &str { "Dumps process memory using ProcDump. Args: pid, output_dir" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Process ID"),
            ParamDef::new("output_dir", "string", false, "Output directory"),
        ])
    }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };
        let out_dir = args["output_dir"].as_str().unwrap_or(".");
        let dump_path = Path::new(out_dir).join(format!("dump_{}.dmp", pid));

        let output = Command::new("procdump")
            .args(["-accepteula", "-ma", &pid.to_string(), &dump_path.to_string_lossy()])
            .output()
            .await;

        match output {
            Ok(o) if o.status.success() => {
                Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
                    "pid": pid,
                    "file": dump_path.to_string_lossy()
                }), start))
            },
            Ok(o) => Ok(StandardResponse::error(tool_name, &String::from_utf8_lossy(&o.stderr))),
            Err(e) => Ok(StandardResponse::error(tool_name, &e.to_string())),
        }
    }
}

use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use crate::engine::frida_handler;
use async_trait::async_trait;
use std::time::Instant;

/// Universal Auto-Deobfuscation Engine
/// 
/// Detects deobfuscation without rules or hardcoded patterns.
/// Uses entropy analysis and memory tracking to capture plaintext
/// as it is decoded at runtime.
pub struct AutoDeobfuscator;

#[async_trait]
impl Tool for AutoDeobfuscator {
    fn name(&self) -> &str { "auto_deobfuscate" }
    
    fn description(&self) -> &str { 
        "Automatically captures deobfuscated strings at runtime using entropy analysis. No rules needed. Args: pid" 
    }
    
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        // Universal deobfuscation script - no hardcoded patterns
        let script = include_str!("../../../resources/scripts/auto_deobfuscate.js");

        if let Err(e) = frida_handler::execute_script(pid, script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "status": "monitoring",
            "detection_methods": [
                "entropy_delta",
                "string_creation",
                "api_resolution"
            ]
        }), start))
    }
}

/// Dynamic API Resolver - Captures all GetProcAddress calls
/// 
/// Tracks dynamically resolved APIs without knowing which ones
/// the malware will use. Universal approach.
pub struct DynamicApiCapture;

#[async_trait]
impl Tool for DynamicApiCapture {
    fn name(&self) -> &str { "capture_dynamic_apis" }
    
    fn description(&self) -> &str { 
        "Captures all dynamically resolved APIs (GetProcAddress/LdrGetProcedureAddress). Args: pid" 
    }
    
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = r#"
            // Universal dynamic API resolution capture
            // No hardcoded API names - captures everything
            
            var resolved = [];
            
            // Hook GetProcAddress - kernel32
            var GetProcAddress = Module.findExportByName('kernel32.dll', 'GetProcAddress');
            if (GetProcAddress) {
                Interceptor.attach(GetProcAddress, {
                    onEnter: function(args) {
                        this.hModule = args[0];
                        var namePtr = args[1];
                        // Check if ordinal or name
                        if (namePtr.toInt32() > 0xFFFF) {
                            this.apiName = namePtr.readAnsiString();
                        } else {
                            this.apiName = 'Ordinal#' + namePtr.toInt32();
                        }
                    },
                    onLeave: function(retval) {
                        if (!retval.isNull()) {
                            var entry = {
                                api: this.apiName,
                                address: retval.toString(),
                                module: this.hModule.toString()
                            };
                            resolved.push(entry);
                            send({type: 'api_resolved', data: entry});
                        }
                    }
                });
            }
            
            // Hook LdrGetProcedureAddress - ntdll (lower level)
            var LdrGetProc = Module.findExportByName('ntdll.dll', 'LdrGetProcedureAddress');
            if (LdrGetProc) {
                Interceptor.attach(LdrGetProc, {
                    onEnter: function(args) {
                        this.hModule = args[0];
                        var ansiStr = args[1];
                        if (!ansiStr.isNull()) {
                            // ANSI_STRING structure: Length, MaxLength, Buffer
                            var bufPtr = ansiStr.add(Process.pointerSize * 2).readPointer();
                            if (!bufPtr.isNull()) {
                                this.apiName = bufPtr.readAnsiString();
                            }
                        }
                    },
                    onLeave: function(retval) {
                        if (retval.toInt32() === 0 && this.apiName) {
                            send({type: 'api_resolved_ldr', api: this.apiName});
                        }
                    }
                });
            }
            
            send({type: 'capture_active', hooks: ['GetProcAddress', 'LdrGetProcedureAddress']});
        "#;

        if let Err(e) = frida_handler::execute_script(pid, script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "status": "capturing",
            "hooks": ["GetProcAddress", "LdrGetProcedureAddress"]
        }), start))
    }
}

/// String Birth Tracker - Monitors creation of new strings in memory
/// 
/// Tracks when new readable strings appear in memory regions.
/// Uses entropy analysis rather than pattern matching.
pub struct StringBirthTracker;

#[async_trait]
impl Tool for StringBirthTracker {
    fn name(&self) -> &str { "track_string_creation" }
    
    fn description(&self) -> &str { 
        "Monitors memory for newly created readable strings. Detects decryption/unpacking. Args: pid" 
    }
    
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = r#"
            // Universal string creation detector
            // No patterns - uses entropy and ASCII analysis
            
            // Hook string manipulation functions
            var stringFuncs = [
                ['kernel32.dll', 'lstrcpyW'],
                ['kernel32.dll', 'lstrcpyA'],
                ['kernel32.dll', 'lstrcatW'],
                ['kernel32.dll', 'lstrcatA'],
                ['msvcrt.dll', 'strcpy'],
                ['msvcrt.dll', 'strcat'],
                ['msvcrt.dll', 'sprintf'],
                ['msvcrt.dll', 'memcpy'],
                ['ntdll.dll', 'RtlCopyMemory']
            ];
            
            stringFuncs.forEach(function(pair) {
                var fn = Module.findExportByName(pair[0], pair[1]);
                if (fn) {
                    Interceptor.attach(fn, {
                        onEnter: function(args) {
                            this.dest = args[0];
                        },
                        onLeave: function(retval) {
                            try {
                                var str = this.dest.readUtf8String();
                                if (str && str.length >= 4 && str.length <= 500) {
                                    // Check if it looks like meaningful data
                                    var printable = 0;
                                    for (var i = 0; i < str.length; i++) {
                                        var c = str.charCodeAt(i);
                                        if (c >= 32 && c <= 126) printable++;
                                    }
                                    var ratio = printable / str.length;
                                    if (ratio > 0.8) {
                                        send({
                                            type: 'string_created',
                                            value: str,
                                            source: pair[1],
                                            address: this.dest.toString()
                                        });
                                    }
                                }
                            } catch(e) {}
                        }
                    });
                }
            });
            
            send({type: 'tracker_active', monitored_functions: stringFuncs.length});
        "#;

        if let Err(e) = frida_handler::execute_script(pid, script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "status": "tracking"
        }), start))
    }
}
